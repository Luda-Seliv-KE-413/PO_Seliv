:toc: macro
:icons: font
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
include::Titul_list_Laba8.adoc[]

toc::[]

---
[.text-left]
== Цель и задание лабораторной работы
Написать программу, которая будет переключать все светодиоды с периодом 0,5 секунды. По нажатию кнопки увеличивать период моргания на 0,1 секунды. При достижении периода 1 секунда сбрасывать до начального периода (0,5 секунды). Для задания периода использовать таймер TIM5 (для данного варианта), а прерывания для кнопки сделать через TIM2.

== Прерывания
Прерывание - это сигнал, сообщающий микропроцессору о наступлении какого-либо события от переферии. При этом выполнение текущей последовательности команд останавливается, и управление передаётся обработчику прерывания, который реагирует на событие и обслуживает его, после чего возвращает управление в прерванный код.

В зависимости от источника прерывания бывают:
* асинхронные;
* синхронные;
* программные.

Различают маскируемые и немаскируемые прерывания.

Управление и обработка прерываниями производится контроллером приоритетных векторных прерываний (NVIC), который является частью ядра Cortex-M.

== Ход работы

В startupF411RE.cpp были добавлены строчки:
[source, cpp, linenums]
----
#include "timerconfig.h"
tTimer2::handler,             //TIM2  	
tTimer5::handler,	        //TIM5 global interrupt
----

Листинг pin.h

[source, cpp, linenums]
----
#ifndef PIN
#define PIN

#include "ipin.h" // for IPin

template<typename Port, int pinNumber>
class Pin : public IPin
{
public:
  void Toggle() const override
  {
  Port::ODR::Toggle(1 << pinNumber);
  }
  void SetLow() const override
  {
    Port::ODR::Write(Port::ODR::Get() & ~(1 << pinNumber));
  }
};

#endif
----

Листинг imode.h

[source, cpp, linenums]
----
#ifndef IMODE
#define IMODE

class IMode
{
public:
  virtual void Update() = 0;
  virtual void Clear() = 0;
};

#endif
----

Листинг alldiod.h

[source, cpp, linenums]
----
#ifndef ALLDIOD
#define ALLDIOD

#include "imode.h" // for IMode
#include <array>

template<auto&...pins>
class Alldiod : public IMode
{
public:
void Update() override
{
  for(auto it: leds)
  {
    it->Toggle();
  }
}

void Clear() override
{
  ClearAll();
}
private:
  std::array<IPin*, sizeof ... (pins)> leds = {static_cast<IPin*> (&pins)...};
  void ClearAll()
  {
    for(auto it: leds)
    {
      it->SetLow();
    }
  }
};

#endif
----

Листинг garland.h

[source, cpp, linenums]
----
#ifndef GARLAND
#define GARLAND

#include "imode.h" // for IMode
#include <array> // for std::array

template<auto& ... modes>
class Garland
{
public:
void NextMode()
{
  pCurrentMode = mModes[i];
  pCurrentMode->Clear();
  i++;
  if(i == mModes.size())
  {
    i = 0;
  }
}
void Update()
{
  pCurrentMode->Update();
}
bool GetFlagInterruption()
{
  return flagInterruption;  
}
void SetFlagInterruption(bool flag)
{
  flagInterruption = flag;
}
private:
  std::array<IMode*, sizeof ... (modes)> mModes = {static_cast<IMode*> (&modes)...};
  IMode* pCurrentMode = mModes[0];
  std::size_t i = 0;
  bool flagInterruption = false;
};

#endif
----

Листинг ibutton.h

[source, cpp, linenums]
----
#ifndef IBUTTON
#define IBUTTON

class IButton
{
public:
  virtual bool IsPressed() = 0;
};

#endif
----

Листинг button.h

[source, cpp, linenums]
----
#ifndef BUTTON
#define BUTTON

#include <IButton.h> // for IButton

#include "ibutton.h"
#include <array>

template<typename Port, int pinNumber>
class Button : public IButton
{
public:
bool IsPressed() override
{
  if(((Port::IDR::Get()&(1 << pinNumber))==0) && (isSet))
  {
    isSet = false;
  } else if(((Port::IDR::Get()&(1 << pinNumber))==(1 << pinNumber)) && (!isSet))
  {
    isSet = true;
    return true;
  }
  return 0;
}
bool GetFlagInterruption()
{
  return flagInterruption;  
}
void SetFlagInterruption(bool flag)
{
  flagInterruption = flag;
}
private:
  bool isSet = true;
  bool flagInterruption = false;
};

#endif
----

Листинг timerconfig.h

[source, cpp, linenums]
----
#ifndef TIMCONFIG
#define TIMCONFIG

#include "pin.h"
#include "alldiod.h"
#include "garland.h"
#include "gpioaregisters.hpp"
#include "gpiocregisters.hpp"
#include "tim5registers.hpp"
#include "timer5.h"
#include "button.h"
#include "tim2registers.hpp"
#include "timer2.h"

extern Pin<GPIOC, 5> pin1;
extern Pin<GPIOC, 8> pin2;
extern Pin<GPIOC, 9> pin3;
extern Pin<GPIOA, 5> pin4;
extern Button<GPIOC, 13> button;

extern Alldiod<pin1, pin2, pin3, pin4> all;
extern Garland<all> garland;

using tTimer5 = Timer5<garland>; 
using tTimer2 = Timer2<button>; 

#endif
----

Листинг timer2.h

[source, cpp, linenums]
----
#ifndef TIMER2
#define TIMER2

#include "tim2registers.hpp" //for TIM5

template <auto& button>
class Timer2
{
public:
  static void handler()
  {
    if(TIM2::SR::UIF::Get() == 1 and
      TIM2::DIER::UIE::Enable::IsSet())
    {
      if(button.IsPressed())
      {
        button.SetFlagInterruption(true);
      }
      TIM2::SR::UIF::Set(0);
    }
  }
};

#endif
----

Листинг timer5.h

[source, cpp, linenums]
----
#ifndef TIMER5
#define TIMER5

#include "tim5registers.hpp" //for TIM5

template <auto& garland>
class Timer5
{
public:
  static void handler()
  {
    if(TIM5::SR::UIF::InterruptPending::IsSet() and TIM5::DIER::UIE::Value1::IsSet())
    {
      garland.SetFlagInterruption(true);
      TIM5::SR::UIF::NoInterruptPending::Set();
    } 
  }
};

#endif
----

Листинг main.cpp

[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include "tim5registers.hpp" // for Tim5
#include "tim2registers.hpp" // for Tim2
#include "pin.h" // for Pin
#include "treeng.h" // for Tree
#include "chess.h" // for Chess
#include "alldiod.h" // for Alldiod
#include "garland.h" // for Garland
#include "button.h" // for Button
#include "nvicregisters.hpp" // for NVIC

using tMsec = std::uint32_t;

const std::uint32_t SystemCoreClock = 16'000'000U;

tMsec period = 500U;

extern "C" {
int __low_level_init(void)
{  
  RCC::APB1ENR::TIM5EN::Enable::Set();
  RCC::APB1ENR::TIM2EN::Enable::Set();

  NVIC::ISER0::Write(1<<28U); // разрешение глоабльного прерывания Tim2
  
  TIM2::PSC::Write(15999U);
  TIM2::CR1::URS::OverflowEvent::Set();
  TIM2::ARR::Write(100U);
  TIM2::SR::UIF::Set(0);
  TIM2::CNT::Write(0);
  TIM2::DIER::UIE::Enable::Set();

  NVIC::ISER1::Set(1<<18); // разрешение глоабльного прерывания Tim5
  
  TIM5::PSC::Write(15999U);
  TIM5::CR1::URS::Value1::Set();
  TIM5::ARR::Write(500U);
  TIM5::SR::UIF::Set(0);
  TIM5::CNT::Write(0);
  TIM5::DIER::UIE::Value1::Set();
  
  return 1;
}
}

void Tim5Arr(tMsec period)
{
  TIM5::ARR::Write(period);
}

Pin<GPIOC, 5> pin1;
Pin<GPIOC, 8> pin2;
Pin<GPIOC, 9> pin3;
Pin<GPIOA, 5> pin4;

Button<GPIOC, 13> button;

Alldiod<pin1, pin2, pin3, pin4> all; // Создание объекта класса режим "все"
Garland<all> garland; // Создание объекта класса режим "гирлянда"
int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set(); //Подача тактирования на порт A
  RCC::AHB1ENR::GPIOCEN::Enable::Set(); //Подача тактирования на порт C
  GPIOC::MODER::MODER13::Input::Set(); //Порт C.13 на ввод
  GPIOA::MODER::MODER5::Output::Set(); //Порт A.5 на вывод
  GPIOC::MODER::MODER5::Output::Set(); //Порт С.5 на вывод
  GPIOC::MODER::MODER8::Output::Set(); //Порт С.8 на вывод
  GPIOC::MODER::MODER9::Output::Set(); //Порт С.9 на вывод
  TIM2::CR1::CEN::Enable::Set();
  TIM5::CR1::CEN::Enable::Set();
  for(;;)
  {
    if(garland.GetFlagInterruption())
    {
      garland.Update();
      garland.SetFlagInterruption(false);
    }
    
    if(button.GetFlagInterruption())
    {
      period = (period < tMsec(1000)) ? (period + tMsec(100U)) : tMsec(500U) ;
      button.SetFlagInterruption(false);
      Tim5Arr(period);
    }
  }
  return 1;
}
----

Результат работы кода представлен ниже.

.Результат работы кода

video::Ура.mp4[opts="muted"]

== Выводы
[.text-left]
В ходе данной работы было проведено ознакомление с прерываниями. Была написана программа, которая реализует переключение светодиодов при помощи прерываний и проверяет нажата ли кнопка через прерывание, по нажатию менялся период "моргания" на 0,1 секунды.