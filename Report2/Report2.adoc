:toc: macro
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление


include::Titul_list_report2.adoc[]

toc::[]

---
[.text-left]
== Цель лекции
Изучение типов данных их размеров, псевдонимов и явных и неявных преобразований. Ознакомление с памятью микроконтроллера CortexM4 и памятью для расположения данных.

== Теоретические основы
=== Типы данных

Под типом данных понимается описание данных определенного вида, для которых известен их способ представления в памяти, следующие из него размерность и диапазон значений, а также определен набор операций.

=== Встроенные типы
[#Встроенные типы С++]
.Встроенные типы С++
[options="header"]
[cols="2,1,7"]
|=====================
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|=====================

=== Модификаторы типов данных
[#Встроенные типы С++ модификаторы]
.Встроенные типы С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

=== Размеры типов данных

Размеры типов не четко определены и могут отличаться для различных микроконтроллеров.

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

*Псевдоним типа данных* - это специальный вид типа данных, который определяется пользователем при использовании существующих базовых типов данных.

Чтобы было понятнее работать с типом можно вводить их псевдонимы (alias). С помощью
ключевого слова *using*.

=== Пользовательские типы

*Пользовательские типы данных* — это типы данных, которые могут быть созданы пользователем на основе того, что доступно в языке программирования. 

Также можно сделать псевдоним типа. Любой класс или структура,
определенная пользователем, будет являться пользовательским типом. 

=== Неявное преобразование типов
Базовые/простые типы неявно можно привести друг к другу. Т.е. компилятор преобразует "неверно" указанный тип в наиболее "подходящий"

Таким образом при неявном преобразовании, при выводе результатов расчетов функции теряется точность вычисления.

=== Явное преобразование типов
Вместо использованя неявного преобразования типа, лучше указать компилятору явное преобразование из одного типа в другой.

Для преобразований из одного типа используют 4 вариантов преобразования:

* static_cast
* const_cast
* reinterpret_cast
* dynamic_cast

*static_cast* позволяет сделать приведение близких типов (целые, пользовательских типов которые могут
создаваться из типов который приводится, и указатель на void* к указателю на любой тип). +
Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент
сборки приложения или библиотеки.

*reinterpret_cast* преобразует типы, несовместимыми друг с другом, и используется для:

* В свой собственный тип
* Указателя в интегральный тип
* Интегрального типа в указатель
* Указателя одного типа в указатель другого типа
* Указателя на функцию одного типа в указатель на функцию другого типа

== Память
ARM имеет общее адресное пространство для данных и команд.

*ARM (Advanced RISC Machines)* - cистема команд и семейство описаний и готовых топологий 32-битных и 64-битных микропроцессорных/микроконтроллерных ядер, разрабатываемых компанией ARM Limited.

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.

Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную
память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в
которую можно писать (ОЗУ).

Также часть адресов этой памяти отведены под регистры управления и регистры периферии.


=== Память микроконтроллера CortexM4

_Микроконтроллер  на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на
три типа_:

* _ПЗУ  (FLASH память в которой храниться программа)_
* _ОЗУ память для хранения временных данных (туда же можно по необходимости переместить программу и
  выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с
  периферией_
* _Память для хранения постоянных данных ЕЕPROM._

Адресное пространство памяти программы (ПЗУ) находится по адресам *0x00000000* по *0x1FFFFFFF*.

Адресное пространство ОЗУ находится по адресам  *0x20000000* по *0x3FFFFFFF*.

Адресное пространство для регистров периферии находится по адресам с *0x40000000*  по *0x5FFFFFFF*.

Памяти EEPROM микропроцессора Stm32F411RE не содержит. +
Более подробно вы можете изучить адресное пространство микропроцессора в спецификации на микропроцессор.

=== Память для расположения данных

Данные в памяти могут быть расположены 3 различными способами:

* Авто(локальные) переменные, которые являются локальными в функции располагаются в регистрах или в стеке.


* Глобальные переменные или статические переменные. В этом случае они инициализируются единожды.


* Динамически размещаемые данные. Данные создаваемые на Куче(Heap)



==== Память под функции(команды)
Для расположения функций используется та же самая память с границами от *0x00000000 - 0xFFFFFFFF*.

По умолчанию весь код будет лежать в сегменте .text, который расположен в readonly памяти (обычно в ROM),
но можно разместить функции и в ОЗУ.


== Выводы
[.text-left]
Прослушав данную лекцию были изучены типы данных их размеры, псевдонимы и явное и неявное преобразования. Также ознакомлены с памятью микроконтроллера CortexM4 и памятью для расположения данных.

Получена _новая_ информация о псевдонимах  и явных и неявных преобразований типов данных. А также о возможности создания пользовательских типов данных и информация о памяти микроконтроллеров. 

[.text-center]
== Ответы на контрольные вопросы
[.text-left]
*Кортеж* -  это упрощенная структура данных, которая имеет определенное число и последовательность значений. При создании экземпляра кортежа определяется число и тип данных каждого значения (или элемента).
