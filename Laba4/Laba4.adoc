:toc: macro
:icons: font
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
include::Titul_list_Laba4.adoc[]

toc::[]

---

== Цель лабораторной работы
Знакомство с настройкой портов микроконтроллера.

== Порты

Порт - это устройство для обмена данными (ввод и вывод). С помощью портов можно управлять работой других устройств. На плате есть 5 портов общего назначения, 16 линий ввода/вывода.

== Порты общего назначения


=== Различные режимы работы портов

Порты могут работать в разных режимах:

* Плавющий цифровой вход (Input floating)
* Цифровой вход с подтяжкой к 1 (Input pull-up)
* Цифровой вход с подтяжкой к 0 (Input-pull-down)
* Аналоговый (Analog)
* Цифровой выход с открытым коллектором с подтяжкой к 1 или к 0 (Output open-drain with pull-up or pull-down capability)
* Цифровой двухтактный выход с подтяжкой к 1 или к 0 (Output push-pull with pull-up or pull-down capability) 
* Альтернативная функция с открытым коллектором с подтяжкой к 1 или к 0 (Alternate function push-pull with pull-up or pull-down capability)
* Альтернативная функция двухтактный выход с подтяжкой к 1 или к 0 (Alternate function open-drain with pull-up or pull-down capability)

=== Цифровой режим

В данном режиме порт имеет два состояния 1(*true*) и  0(*false*) или говоря на языке электроники *Hihg* и *Low*. Эти сигналы соотвествуют уровню питания микроконтроллера, для нашего микроконтроллера обычно *High* соотвествует 3-3.3В, a *Low* - 0 В.

Когда порт настроен как цифровой выход им можно управлять. Например, если вы задали состояние порта High, то порт подключается к питанию, в итоге на ножке порта появляется высокий уровень напряжения. В случае, если вы задали Low, на ножке порта появляется низкий уровень напряжения или 0.

Когда порт настроен как цифровой вход его сопротивление бесконечно, контакт никуда не подключен ни к земле ни к питанию, поэтому ток никуда не течет. Любое напряжение
на такой ножке будет интерпретирована как 1 или 0, в зависимости от уровня напряжения высокого или низкого. В таком случае это называется "подвешенная" или плавающая ножка и наводка или шум на этой ножке может быть интерпретирован как 1 или 0 в зависимости от уровня шума. Таким образом такая плавающая "ножка" не очень хорошо, так как могут енерироваться
ложные переходы

=== Цифровой вход с подтяжкой

Плавающий сигнал на подвешенной ножке может быть причиной следующих проблем:

* Разное значение при считывании (1 или 0) в разные моменты времени;
* Ложные переходы (если настроено прерывание, то вы псотоянно будет входить в обработчик);
* Повышенно потребление из-за того, что схема входного буфера для ножки потребляет ток когда сигнал на ножке не полностью High или Low

Чтобы избавиться от плавющего сигнала на ножке обычно её подтягивают к 0 или 1.
Обычно эта опция уже есть внутри микроконтроллера и может быть настроена

=== Регистры портов общего назначения

* *GPIOx_MODER (port mode register)*.  Задает режимы работы индивидуально каждого из вывода порта. 
** Каждый из выводов GPIO может быть настроен как вход, выход, работать в аналоговом режиме, или подключен к одной из альтернативных функций. 

* *GPIOx_OSPEEDR (port output speed register)*. Задает скорость работы порта: 
** 400кГц, 2МГц, 10МГц и 40Мгц.

* *GPIOx_PUPDR (port pull-up/pull-down register)*. Задает подключение подтягивающих резисторов
** Без подтягивающего резистора, с подтяжкой к «+» питания, с подтяжкой к «gnd» земле. 

* *GPIOx_IDR (input data register)*. регистр входных данных, из которого считывается состояние входов порта.

* *GPIOx_ODR (output data register)*. регистр выходных данных. Запись числа в младшие 16 бит, приводит к появлению соответствующих уровней на выводах порта.

* *GPIOx_OTYPER (port output type register)*. В режиме выхода или альтернативной функции, соответствующий бит регистра устанавливает тип выхода. 
** Push-Pull (двухтактный) или Open Drain (выход с открытым коллектором).

* *GPIOx_BSRR (port bit set/reset register)*. Это регистр побитовой установки/сброса данных на выходных линиях порта.
** 32 разряда этого регистра позволяют индивидуально установить или сбросить каждый из 16 младших разрядов регистра *GPIOx_ODR*.

** Младшие 16 разрядов регистра *GPIOx_BSRR* отвечают за установку соответствующего бита регистра *GPIOx_ODR* в «1», старшие 16 разрядов сбрасывают этот бит. Установка/сброс осуществляются записью «1» в соответствующий разряд. Запись «0» никак не воздействует на состояние соответствующего бита выходного регистра данных. При одновременной записи двух единиц в биты установки и сброса, приоритет имеет операция установки бита.

* *GPIOxLCKR (port configuration lock register)*. Позволяет «заморозить», то есть защитить от изменения текущую настройку конфигурации. Можно запретить модификацию следующих регистров управления: *GPIOx_MODER*, *GPIOx_OTYPER*, *GPIOx_OSPEEDR*, *GPIOx_PUPDR*, *GPIOx_AFRL*,  *GPIOx_AFRH*.

== Задание
Сделать программу, которая будет переключать светодиоды на плате по алгоритму: включить 1 светодиод, задержка, включить 2 светодиод, задержка и т.д, а затем погасить в обратном порядке.

=== Реализация 1. "Прямой" код

Листинг кода
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include <iostream>

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C"
{
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  return 1;
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)
  {
    asm volatile("");
  }
}

int main()
{
  //Подать тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Установка порта А (GPIOA) 5 бит (MODER5) на выход
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порт С.5
  GPIOC::MODER::MODER5::Output::Set() ;
  //Порт С.8
  GPIOC::MODER::MODER8::Output::Set() ;
  //Порт с.9
  GPIOC::MODER::MODER9::Output::Set() ;

  for(;;)
  {
      GPIOC::ODR::ODR5::High::Set();
      delay(1000000);
    
      GPIOC::ODR::ODR8::High::Set();
      delay(1000000);
    
      GPIOC::ODR::ODR9::High::Set();
      delay(1000000);
     
      GPIOA::ODR::ODR5::High::Set();
      delay(1000000);
    
      GPIOA::ODR::ODR5::Low::Set();
      delay(1000000);
    
      GPIOC::ODR::ODR9::Low::Set();
      delay(1000000);
    
      GPIOC::ODR::ODR8::Low::Set();
      delay(1000000);
      
      GPIOC::ODR::ODR5::Low::Set();
      delay(1000000);
  }
  return 1;
}

----

.Видео - Демонстрация "Елочки"
video::VID4.1_Ёлочка.mp4[opts="muted"]

=== Идея реализации через классы

Листинг Pin.h
[source, cpp, linenums]
----
#ifndef PIN
#define PIN

#include "gpioaregisters.hpp" //for GPIOA

template<typename Port, int pinNumber>
class Pin
{
public:
void Toggle()
{
Port::ODR::Toggle(1«pinNumber);
}
};


#endif
----

Листинг main.cpp
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include "Pin.h" //for  Pin
#include <iostream>

std::uint32_t SystemCoreClock = 16'000'000U;


void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)
  {
    asm volatile("");
  }
}

template<auto& ...pin>
class Pins
{
  public:
  void ToggleAll()
  {
    (..., pin.Toggle());
  }
};
Pin<GPIOA, 5> pin1;
Pin<GPIOC, 5> pin2;
Pin<GPIOC, 8> pin3;
Pin<GPIOC, 9> pin4;
Pins<pin1, pin2, pin3, pin4> pins;


int main()
{
  //Подать тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Установка порта А (GPIOA) 5 бит (MODER5) на выход
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порт С.5
  GPIOC::MODER::MODER5::Output::Set() ;
  //Порт С.8
  GPIOC::MODER::MODER8::Output::Set() ;
  //Порт с.9
  GPIOC::MODER::MODER9::Output::Set() ;
  
  //Girland.NexMode();
  for(;;)
  {     
    pins.ToggleAll();
     //Girland.Upadate();
    delay(1000000);
  }
  return 1;
}


----

.Видео - Демонстрация идеи
video::VID4.2_Ёлочка.mp4[opts="muted"]

=== Реализация 2. Через классы

Листинг pin.h
[source, cpp, linenums]
----
#ifndef PIN
#define PIN

#include "gpiocregisters.hpp" // for GPIOC
#include "gpioaregisters.hpp" // for GPIOA
#include "IPin.h" // for IPin

template<typename Port, int pinNumber>
class Pin : public IPin
{
public:
  void Toggle() const override
  {
    Port::ODR::Toggle(1 << pinNumber) ;
  }
} ;

#endif
----

Листинг ipin.h
[source, cpp, linenums]
----
#ifndef IPIN
#define IPIN

class IPin
{
public:
  virtual void Toggle() const = 0;
};

#endif
----

Листинг imode.h
[source, cpp, linenums]
----
#ifndef IMODE
#define IMODE

class IMode
{
public:
  virtual void Update() = 0;
};

#endif
----

Листинг treeng.h
[source, cpp, linenums]
----
#ifndef TREENG
#define TREENG

#include "imode.h" // for IMode
#include <array>

template<auto&...pins>
class Treeng : public IMode
{
public:
  void Update() override
  {
    leds[i++]->Toggle();
    if(i == leds.size())
    {
      i = 0;
    }
  }
private:
  std::size_t i = 0;
  std::array<IPin*, sizeof ...(pins)> leds = {&pins...};
};

#endif
----

Листинг main.cpp
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include "Pin.h"
#include "IPin.h"
#include <iostream>
#include <array>
#include "treeng.h" // for Treeng

std::uint32_t SystemCoreClock = 16'000'000U;

void delay(int cycles)
    {
      for(int i = 0; i < cycles; ++i)
      {
        asm volatile("");
      }
    }

Pin<GPIOA,5> pin1 ;
Pin<GPIOC,9> pin2 ;
Pin<GPIOC,8> pin3 ;
Pin<GPIOC,5> pin4 ;
Treeng<pin1, pin2, pin3, pin4> treeng;
int main()
{

    //Подать тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Установка порта А (GPIOA) 5 бит (MODER5) на выход
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порт С.5
  GPIOC::MODER::MODER5::Output::Set() ;
  //Порт С.8
  GPIOC::MODER::MODER8::Output::Set() ;
  //Порт с.9
  GPIOC::MODER::MODER9::Output::Set() ;

  for(;;)
  {
    // Гирлянда: зажечь 1 светодиод, задержка, 2, задержка и т.д. И потом также гасить
    treeng.Update();
    delay(1000000);
  }
  return 1;
}
----

.Видео - Демонстрация "Елочка через классы"
video::VID4.3_Ёлочка.mp4[opts="muted"]

== Выводы
В ходе данной работы ознакомились с портами и их режимами работы. 
Также была написана программа "Ёлочка", которая переключала светодиоды по заданному алгоритму.


//== Ответы на контрольные вопросы
//[.text-left]
// закоментировать или убрать, если таковых нет
