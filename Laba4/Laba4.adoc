:toc: macro
:icons: font
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
include::Titul_list_Laba4.adoc[]

toc::[]

---

== Цель лабораторной работы
Знакомство с настройкой портов микроконтроллера.

== Порты

Порт - это устройство для обмена данными (ввод и вывод). С помощью портов можно управлять работой других устройств. На плате есть 5 портов общего назначения, 16 линий ввода/вывода.

== Порты общего назначения


=== Различные режимы работы портов

Порты могут работать в разных режимах:

* Плавющий цифровой вход (Input floating)
* Цифровой вход с подтяжкой к 1 (Input pull-up)
* Цифровой вход с подтяжкой к 0 (Input-pull-down)
* Аналоговый (Analog)
* Цифровой выход с открытым коллектором с подтяжкой к 1 или к 0 (Output open-drain with pull-up or pull-down capability)
* Цифровой двухтактный выход с подтяжкой к 1 или к 0 (Output push-pull with pull-up or pull-down capability) 
* Альтернативная функция с открытым коллектором с подтяжкой к 1 или к 0 (Alternate function push-pull with pull-up or pull-down capability)
* Альтернативная функция двухтактный выход с подтяжкой к 1 или к 0 (Alternate function open-drain with pull-up or pull-down capability)

=== Цифровой режим

В данном режиме порт имеет два состояния 1(*true*) и  0(*false*) или говоря на языке электроники *Hihg* и *Low*. Эти сигналы соотвествуют уровню питания микроконтроллера, для нашего микроконтроллера обычно *High* соотвествует 3-3.3В, a *Low* - 0 В.

Когда порт настроен как цифровой выход им можно управлять. Например, если вы задали состояние порта High, то порт подключается к питанию, в итоге на ножке порта появляется высокий уровень напряжения. В случае, если вы задали Low, на ножке порта появляется низкий уровень напряжения или 0.

Когда порт настроен как цифровой вход его сопротивление бесконечно, контакт никуда не подключен ни к земле ни к питанию, поэтому ток никуда не течет. Любое напряжение
на такой ножке будет интерпретирована как 1 или 0, в зависимости от уровня напряжения высокого или низкого. В таком случае это называется "подвешенная" или плавающая ножка и наводка или шум на этой ножке может быть интерпретирован как 1 или 0 в зависимости от уровня шума. Таким образом такая плавающая "ножка" не очень хорошо, так как могут енерироваться
ложные переходы

=== Цифровой вход с подтяжкой

Плавающий сигнал на подвешенной ножке может быть причиной следующих проблем:

* Разное значение при считывании (1 или 0) в разные моменты времени;
* Ложные переходы (если настроено прерывание, то вы псотоянно будет входить в обработчик);
* Повышенно потребление из-за того, что схема входного буфера для ножки потребляет ток когда сигнал на ножке не полностью High или Low

Чтобы избавиться от плавющего сигнала на ножке обычно её подтягивают к 0 или 1.
Обычно эта опция уже есть внутри микроконтроллера и может быть настроена

=== Регистры портов общего назначения

* *GPIOx_MODER (port mode register)*.  Задает режимы работы индивидуально каждого из вывода порта. 
** Каждый из выводов GPIO может быть настроен как вход, выход, работать в аналоговом режиме, или подключен к одной из альтернативных функций. 

* *GPIOx_OSPEEDR (port output speed register)*. Задает скорость работы порта: 
** 400кГц, 2МГц, 10МГц и 40Мгц.

* *GPIOx_PUPDR (port pull-up/pull-down register)*. Задает подключение подтягивающих резисторов
** Без подтягивающего резистора, с подтяжкой к «+» питания, с подтяжкой к «gnd» земле. 

* *GPIOx_IDR (input data register)*. регистр входных данных, из которого считывается состояние входов порта.

* *GPIOx_ODR (output data register)*. регистр выходных данных. Запись числа в младшие 16 бит, приводит к появлению соответствующих уровней на выводах порта.

* *GPIOx_OTYPER (port output type register)*. В режиме выхода или альтернативной функции, соответствующий бит регистра устанавливает тип выхода. 
** Push-Pull (двухтактный) или Open Drain (выход с открытым коллектором).

* *GPIOx_BSRR (port bit set/reset register)*. Это регистр побитовой установки/сброса данных на выходных линиях порта.
** 32 разряда этого регистра позволяют индивидуально установить или сбросить каждый из 16 младших разрядов регистра *GPIOx_ODR*.

** Младшие 16 разрядов регистра *GPIOx_BSRR* отвечают за установку соответствующего бита регистра *GPIOx_ODR* в «1», старшие 16 разрядов сбрасывают этот бит. Установка/сброс осуществляются записью «1» в соответствующий разряд. Запись «0» никак не воздействует на состояние соответствующего бита выходного регистра данных. При одновременной записи двух единиц в биты установки и сброса, приоритет имеет операция установки бита.

* *GPIOxLCKR (port configuration lock register)*. Позволяет «заморозить», то есть защитить от изменения текущую настройку конфигурации. Можно запретить модификацию следующих регистров управления: *GPIOx_MODER*, *GPIOx_OTYPER*, *GPIOx_OSPEEDR*, *GPIOx_PUPDR*, *GPIOx_AFRL*,  *GPIOx_AFRH*.

== Задание
Сделать программу, которая будет переключать светодиоды на плате по алгоритму: включить 1 светодиод, задержка, включить 2 светодиод, задержка и т.д, а затем погасить в обратном порядке. 
//Выполнить основную часть программы с помощью отдельного класса.

//Листинг pin.h
//[source, cpp, linenums]
//----
//#ifndef PIN
//#define PIN

//#include "gpiocregisters.hpp" // for GPIOC
//#include "gpioaregisters.hpp" // for GPIOA

//template<typename Port, int pinNumber>
//class Pin
//{
//public:
  //void Toggle()
  //{
    //Port::ODR::Toggle(1 << pinNumber) ;
  //}
//} ;

//#endif

//#ifndef GarLand
//#define GarLand

//template<auto& pin1,auto& pin2,auto& pin3,auto& pin4, int& time>
//class Garland
//{
//public:
    //void delay(int cycles)
    //{
      //for(int i = 0; i < cycles; ++i)
      //{
        //asm volatile("");
      //}
    //}
    //void Toggle_Garland()
    //{
      //pin1.Toggle();
      //delay(time);
      //pin2.Toggle();
      //delay(time);
      //pin3.Toggle();
      //delay(time);
      //pin4.Toggle();
      //delay(time);
    //}
//};

//#endif
//----

Листинг main.cpp
//[source, cpp, linenums]
//----
//#include "rccregisters.hpp" // for RCC
//#include "gpioaregisters.hpp" // for GPIOA
//#include "pin.h"
//#include "gpiocregisters.hpp" // for GPIOC

//std::uint32_t SystemCoreClock = 16'000'000U;

//extern "C" {
  //int __low_level_init(void)
  //{
  //}
//}

//Pin<GPIOA,5> pin1 ;
//Pin<GPIOC,9> pin2 ;
//Pin<GPIOC,8> pin3 ;
//Pin<GPIOC,5> pin4 ;
//int time = 2500000 ;
//Garland<pin1,pin2,pin3,pin4,time> garland;

//int main()
//{
  
  //Подать тактирование на порт А
  //RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  //RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //GPIOA::MODER::MODER5::Output::Set() ; // установить порт А.5 на выход
  //Светодиоды на портах C.5,C.8, C.9 на выход
  //GPIOC::MODER::MODER5::Output::Set() ;
  //GPIOC::MODER::MODER8::Output::Set() ;
  //GPIOC::MODER::MODER9::Output::Set() ;
  
  //for(;;)
  //{
    // Гирлянда: зажечь 1 светодиод, задержка, 2, задержка и т.д. И потом также гасить
    //garland.Toggle_Garland() ;
  //}
  
  //return 1;
//}
//----

На видео представлена работа программы.

.Видео - Демонстрация "гирлянды"
//video::Video.mp4[opts="muted"]

== Выводы
В ходе данной работы ознакомились с портами и их режимами работы. 
Также была написана программа "Гирлянда/Ёлочка", которая переключала светодиоды по заданному алгоритму.


//== Ответы на контрольные вопросы
//[.text-left]
// закоментировать или убрать, если таковых нет
