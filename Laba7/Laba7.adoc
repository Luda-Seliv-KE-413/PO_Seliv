:toc: macro
:icons: font
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
include::Titul_list_Laba7.adoc[]

toc::[]

---
[.text-left]
== Цель лабораторной работы
Изучить назначения таймеров в микроконтроллерах. Научится использовать таймеры при написании программы.

== Задание

[.text-left]
Написать программу, которая будет переключать все светодиоды с периодом 0,5 секунды. По нажатию кнопки увеличивать период моргания на 0,1 секунды. При достижении периода 1 секунда сбрасывать до 0,5 секунды. Для задания периода использовать таймер TIM5 (для данного варианта).

== Теоритические основы
=== Таймеры
Одна из основных задач таймеров в микроконтроллерах это отсчитывать точные интервалы времени. +
Также таймеры могут использоваться для измерения частоты, периодов, генерации ШИМ-сигналов и переменных сигналов различной формы.

Микроконтроллер STM32F411 имеет:

* системный таймер (SYSTEM TIMER) - простой таймер, встроенный в ядро, имеет 24 бита;
* TIM1 - расширенный 16-битный таймер;
* TIM2-TIM5 - таймеры общего назначения, причем TIM2 и TIM5 32-битные, а остальные 16-битные;
* TIM9-TIM11 - 16-битные таймеры.

=== Системный таймер
Самый просто таймер, встроенный в ядро ARMv7, на котором построено ядро CortexM4, его поддерживают все микроконтроллеры на этом ядре.

* 24 - битный таймер считающий вниз от заданного значения до нуля;
* используется только 3 регистра для настройки:
1. SysTick Control and Status Register (SYST_CSR) (регистр для управления системным таймером),
2. Регистр перезагружаемого значения LOAD (В этом регистре хранится значение, которое будет записано в системный таймер как только его счетчик достигнет 0),
3. Регистр текущего значения VAL (В этом регистре хранится текущее значение счетчика).

=== Таймеры TIM2 и TIM5
* Таймеры 32 битные;
* Таймеры тактируются от шины APB1; 
* умеют работатьс инкрементальными энкодерами и датчиками Холла;
* несколько таймеров можно синхронизировать между собой.
* Таймеры могут использоваться для:
** Захвата сигнала (Защелкивать значение, когда на выводе порта например 0 сменился на 1)
** Сравнения (Считать до значения в регистре сравнения и установить/сбросить/переключить вывод порта)
** Генерации ШИМ (Генерировать прямоугольный сигнал с различной скважностью на вывод порта)
** Генерации одиночного импульса;
* Таймеры могут генеририровать следующие события:
** Переполнение
** Захват сигнала
** Сравнение
** Событие-триггер

Настройка таймеров происходит с помощью записи в их регистры нужных бит. +
В данной работе будет использоваться таймер TIM5, поэтому рассмотрим его подробнее. Таймер TIM5 тактируется от шины APB1. 

Для организации задержки таймера TIM5 нужно выполнить следующие:

1. Подать тактирование на модуль таймера​
2. Установить делитель частоты для таймера в регистре PSC​
3. Установить источник генерации прерываний по событию переполнение с помощью бита URS в регистре CR1​
4. Установить значение до которого счетчик будет считать в регистре перезагрузке ARR​
5. Скинуть флаг генерации прерывания UIF по событию в регистре SR​
6. Установить начальное значение счетчика в 0 в регистре CNT​
7. Запустить счетчик с помощью бита EN в регистре CR1​
8. Проверять, пока не будет установлен флаг генерации прерывания по событию UIF в регистре SR​
9. Как только флаг установлен, остановить счетчик, сбросить бит EN в регистре CR1. Сбросить флаг генерации прерывания UIF по событию в регистре SR


=== Ход работы

Листинг main.cpp
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include "Pin.h"
#include "Button.h"
#include "Alldiod.h"// for Alldiod
#include "stkregisters.hpp" // for STK
#include "scbregisters.hpp" // for ICSR
#include "tim5registers.hpp" // for TIM5

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C"
{
  int __low_level_init(void)
  {
    RCC::APB1ENR::TIM5EN::Enable::Set();
    return 1;
  }
}

using tMsec = std::uint32_t;

void delay(tMsec period)
{
  const auto timerValue = static_cast<uint32_t>(SystemCoreClock / 1000U - 1U);
  TIM5::PSC::Write(timerValue);
  TIM5::CR1::URS::Value1::Set(); 
  TIM5::ARR::Write(period); 
  TIM5::SR::UIF::Set(0); 
  TIM5::CNT::Write(0); 
  int h = TIM5::CNT::Get();

  TIM5::CR1::CEN::Enable::Set(); 
  while(TIM5::SR::UIF::Get() == 0) 
  {
  }
  TIM5::CR1::CEN::Disable::Set(); 
  TIM5::SR::UIF::Set(0); 
}

Pin<GPIOA,5> pin1 ;
Pin<GPIOC,9> pin2 ;
Pin<GPIOC,8> pin3 ;
Pin<GPIOC,5> pin4 ;
Alldiod<pin1, pin2, pin3, pin4> all;
Button<GPIOC, 13> button; // пользовательская кнопка


int main()
{
  //C.13 (кнопка)
  GPIOC::MODER::MODER13::Input::Set();
  //Подать тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  //Установка порта А (GPIOA) 5 бит (MODER5) на выход
  GPIOA::MODER::MODER5::Output::Set();
  //Порт С.5
  GPIOC::MODER::MODER5::Output::Set();
  //Порт С.8
  GPIOC::MODER::MODER8::Output::Set();
  //Порт С.9
  GPIOC::MODER::MODER9::Output::Set();

  tMsec period = 500U;
  for(;;)
  {
    all.Update();
    if(button.IsPressed())
    {
      period=(period <=tMsec(1000)) ? (period + tMsec(100U)) : tMsec(500U);
    }
    delay(period);
  }
  return 1;
}
----

На видео представлена работа программы.

.Видео - Таймер
video::VID.mp4[opts="muted"]

== Выводы
[.text-left]
В ходе данной работы было проведено ознакомление с таймерами. Также был написан код, реализующий включение-выключение светодиодов по таймеру. Результат работы кода был представлен на видео.